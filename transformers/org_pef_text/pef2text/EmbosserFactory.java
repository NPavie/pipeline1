package org_pef_text.pef2text;

import java.io.IOException;
import java.io.OutputStream;
import java.util.HashMap;

import org_pef_text.TableFactory;

/**
 * 
 * The embosser factory can build settings for the
 * EmbosserTypes.
 * 
 * @author  Joel Hakansson, TPB
 * @version 10 okt 2008
 * @since 1.0
 */
public class EmbosserFactory {
	public static enum EmbosserType {NONE, INDEX_EVEREST, INDEX_BASIC};
	private HashMap<String, String> settings;
	private EmbosserType t;
	
	public EmbosserFactory() {
		settings = new HashMap<String, String>();
		t = EmbosserType.NONE;
	}

    /**
     * Associates the specified value with the specified key in this map.
     * If the map previously contained a mapping for this key, the old
     * value is replaced.
     *
     * @param key key with which the specified value is to be associated.
     * @param value value to be associated with the specified key.
     * @return previous value associated with specified key, or <tt>null</tt>
     *	       if there was no mapping for key.  A <tt>null</tt> return can
     *	       also indicate that the HashMap previously associated
     *	       <tt>null</tt> with the specified key.
     */
	public String setProperty(String key, String value) { return settings.put(key, value); }
	
	public String getProperty(String key) { return settings.get(key); }
	
	public void setEmbosserType(EmbosserType t) {
		this.t = t;
	}
	
	public EmbosserType getEmbosserType() {
		return t;
	}
	
	public AbstractEmbosser newEmbosser(OutputStream os) throws IOException {
		ConfigurableEmbosser.Builder b;
		TableFactory btb;
		switch (t) {
			case NONE:
				btb = new TableFactory();
				btb.setTable(settings.get("table"));
				btb.setFallback(settings.get("fallback"));
				btb.setReplacement(settings.get("replacement"));
				b = new ConfigurableEmbosser.Builder(os, btb.newTable());
				b.breaks(settings.get("breaks"));
				b.padNewline(settings.get("padNewline"));
				b.supports8dot(true);
				b.supportsDuplex(true);
				return b.build();
			case INDEX_BASIC:
			case INDEX_EVEREST:
				btb = new TableFactory();
				btb.setTable(TableFactory.TableType.EN_US);
				btb.setFallback(settings.get("fallback"));
				btb.setReplacement(settings.get("replacement"));
				b = new ConfigurableEmbosser.Builder(os, btb.newTable());
				b.breaks(LineBreaks.Type.DOS);
				b.padNewline(ConfigurableEmbosser.Padding.NONE);
				b.supportsDuplex(true);
				b.header(new byte[]{0x1b, 0x0f, 0x02, 0x30, 0x2c, 0x30, 0x2c, 0x30, 0x2c, 0x30, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x30, 0x2c, 0x30, 0x2c, 0x30, 0x2c, 0x30, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x30, 0x2c, 0x30, 0x2c, 0x78, 0x2c, 0x30, 0x2c, 0x30, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x31, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x1b, 0x0f, 0x1b, 0x0f, 0x02, 0x78, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x39, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x31, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x1b, 0x0f, 0x1b, 0x0f, 0x02, 0x78, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x31, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x31, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x78, 0x2c, 0x1b, 0x0f, 0x00});
    			b.footer(new byte[]{0x1a});
    			return b.build();
		}
		throw new IllegalArgumentException("Cannot find embosser type " + t);
	}

}
